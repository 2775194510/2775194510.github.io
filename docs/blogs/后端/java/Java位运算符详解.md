---
title: 4：Java位运算符详解
date: 2023-09-05
categories:
  - 后端
tags:
  - java
---
## 1：运算符详解
### 1）异或运算符 ^
>  ^ 是针对二进制的二目运算符。运算规则：两个二进制数值如果在同一位上相同，则结果中该位为0，否则为1，比如1011 ^ 0010 = 1001。

代码示例：
```java
    private static void yihuo() {
        //^是针对二进制的二目运算符。运算规则：两个二进制数值如果在同一位上相同，则结果中该位为0，否则为1，比如1011 ^ 0010 = 1001。
        // 1 0 1 1
        // 0 0 1 0
        //  ->
        // 1 0 0 1
        System.out.println("异或运算符");
        System.out.println(11 ^ 2);   // 9
    }
```

### 2）或运算符 |
>  | 是针对二进制的二目运算符。运算规则：两个二进制数值如果在同一位上至少有一个1，则结果中该位为1，否则为0，比如 1011 | 0010 = 1011。

代码示例：
```java
    private static void huo() {
        //|是针对二进制的二目运算符。运算规则：两个二进制数值如果在同一位上至少有一个1，则结果中该位为1，否则为0，比如 1011 | 0010 = 1011。
        // 1 0 1 1
        // 0 0 1 0
        //  ->
        // 1 0 1 1
        System.out.println("或运算符");
        System.out.println(11 | 2);   // 11
    }
```
### 3）与运算符 &
>  & 是针对二进制的二目运算符。需要注意的是&&是java中判断条件之间表示“和”的标识符，&是一个二目运算符，两个二进制数值如果在同一位上都是1，则结果中该位为1，否则为0，可以认为两个都是true(1)，结果也为true(1)，比如1011 & 0110 = 0010。

代码示例：
```java
private static void yu() {
        // &是是针对二进制的二目运算符。需要注意的是&&是java中判断条件之间表示“和”的标识符，&是一个二目运算符，
        // 两个二进制数值如果在同一位上都是1，则结果中该位为1，否则为0，可以认为两个都是true(1)，结果也为true(1)，
        // 比如1011 & 0110 = 0010。

        // 1 0 1 1
        // 0 1 1 0
        //  ->
        // 0 0 1 0
        System.out.println("与运算符");
        System.out.println(11 & 2);   // 2
    }
```
### 4）移位符
- `\>\> x（常数）`: 向右移动x位（顶点在哪个方向就往哪个方向移动），如果该数是正数，则高位（最左边）补x个0，如果是负数，则最高位补x个1。  
- `<\<x（常数）`: 向左移动x位（顶点在哪个方向就往哪个方向移动），无论正负数低位（最右边）都补x个0。  
- `\<\<\<`: 无该表示方式。
- `\>\>\>x(常数)`: 表示无符号右移x位，所谓无符号是与\>\>x对比，该操作在移动后，无论正负数高位（最左边）都补0。

<p style="color: yellow"><<（左移运算符）</p>

#### 举例1：-20<<2
`原码`：10000000 00000000 00000000 00010100

`反码`： 11111111   11111111   11111111  11101011（符号位不变，其他位取反）

`补码`： 11111111   11111111   11111111  11101100（反码 + 1）

左移两位（最右边两位添0）

`补码`： 11111111   11111111   11111111  10110000

`反码`： 11111111   11111111   11111111  10101111（补码 - 1）

`原码`： 10000000 00000000 00000000 01010000（符号位不变，其他位取反）

`结果`：-80
#### 举例2：20<<2
`原码（反码，补码）`：00000000 00000000 00000000 00010100

左移两位（最右边两位添0）

`原码（反码，补码）`：00000000 00000000 00000000 01010000

`结果`：80

<p style="color: yellow">>>（右移运算符）</p>

#### 举例1：-20>>2
`原码`：10000000 00000000 00000000 00010100

`反码`： 11111111   11111111   11111111  11101011（符号位不变，其他位取反）

`补码`： 11111111   11111111   11111111  11101100（反码 + 1）

右移两位（最左边两位添1）

`补码`： 11111111   11111111   11111111  11111011

`反码`： 11111111   11111111   11111111  11111010（补码 - 1）

`原码`： 10000000 00000000 00000000 00000101（符号位不变，其他位取反）

`结果`：-5

#### 举例2：20>>2

`原码（反码，补码）`：00000000 00000000 00000000 00010100

右移两位（最左边两位添0）

`原码（反码，补码）`：00000000 00000000 00000000 00000101

`结果`：5

<p style="color: yellow">>>>（无符号右移运算符）</p>

#### 举例1：-2>>>1
`原码`：10000000 00000000 00000000 00000010

`反码`： 11111111  11111111   11111111  11111101（符号位不变，其他位取反）

`补码`： 11111111  11111111   11111111  11111110（反码 + 1）

右移1位（无符号位运算符，最左边一位只添0）

`补码`： 01111111  11111111   11111111  11111111

`反码`： 01111111  11111111   11111111  11111111（高位为0，正数）

`原码`： 01111111  11111111   11111111  11111111（与反码相同）

`结果`：2147483647
#### 举例2：2>>>1
`原码（反码，补码）`：00000000 00000000 00000000 00000010

右移一位（最左边一位添0）

`原码（反码，补码）`：00000000 00000000 00000000 00000001

`结果`：1

## 2：练习场

### 1）统计两个数的二进制表示有多少位不同
> 实现思路：那就先求出 不相同位的为0，相同位的为1，所以在这里使用异或运算，然后再求出上述结束中有多少位为1就可以了。
对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可。
[leetcode 461 汉明距离](https://leetcode.cn/problems/hamming-distance/description/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)
```java
class Solution {
    public int hammingDistance(int x, int y) {
        int count = 0;
        // 1.异或运算，
        int noSimpleNum = x ^ y;
        // 2.直接求出 noSimpleNum 有多少1即可
        while(noSimpleNum != 0){
            if((noSimpleNum & 1) == 1){
                count++;
            }
            // 2.1每次右移一位
            noSimpleNum = noSimpleNum >> 1;
        }
        return count;
    }
}
```

