---
title: 6：栈
date: 2024-03-28
sidebar: auto
categories:
  - 数据结构
tags:
  - 数据结构

author: 胡昊泽

---

## 1：什么是栈？

- 1) `栈` 的英文为(stack) 
- 2) 栈是一个 `先入后出(FILO-First In Last Out)` 的有序列表。 
- 3) `栈(stack)` 是限制线性表中元素的 `插入` 和 `删除` 只能在线性表的同一端进行的一种特殊线性表。允许 `插入` 和 `删除` 的一端，为变化的一端，称为 `栈顶(Top)`，另一端为固定的一端，称为 `栈底(Bottom)`。 
- 4) 根据 `栈` 的定义可知，**`最先`放入栈中元素在 `栈底`**，**`最后`放入的元素在 `栈顶`**，**而删除元素刚好相反，最后放入的元 素最先删除，最先放入的元素最后删除**
- 5) 图解方式说明 `出栈(pop)` 和 `入栈(push)`的概念

![alt text](./assets/image13.png)

## 2：栈的基本方法

- 1) **push(Object item)**：将元素item压入 **栈顶**。
- 2) **pop()**：弹出 **栈顶** 元素，并将其从栈中删除。
- 3) **peek()**：返回 **栈顶 元素，但不删除它。
- 4) **isEmpty()**：判断栈是否为空，返回布尔值。
- 5) **search(Object item)**：搜索元素item在栈中的位置（从栈顶开始），如果找到则返回其距离栈顶的位置（栈顶为1），如果未找到则返回-1。
- 6) **clear()**：对当前栈进行清空。

## 3：栈的实现方式

### 3.1 基于简单数组的实现方式

使用 `简单数组` 作为底层数据结构来实现 `栈`，通过将栈顶元素的索引存储在变量中，实现压栈和弹栈操作，每次压栈时将元素添加到数组末尾，每次弹栈时将栈顶元素从数组中删除。由于数组的长度是固定的，需要提前定义栈的最大容量。

#### 完全版
```java
public class ArrayStackDemo {

	public static void main(String[] args) {
		//测试一下ArrayStack 是否正确
		//先创建一个ArrayStack对象->表示栈
		ArrayStack stack = new ArrayStack(4);
		String key = "";
		boolean loop = true; //控制是否退出菜单
		Scanner scanner = new Scanner(System.in);
		
		while(loop) {
			System.out.println("show: 表示显示栈");
			System.out.println("exit: 退出程序");
			System.out.println("push: 表示添加数据到栈(入栈)");
			System.out.println("pop: 表示从栈取出数据(出栈)");
			System.out.println("请输入你的选择");
			key = scanner.next();
			switch (key) {
			case "show":
				stack.list();
				break;
			case "push":
				System.out.println("请输入一个数");
				int value = scanner.nextInt();
				stack.push(value);
				break;
			case "pop":
				try {
					int res = stack.pop();
					System.out.printf("出栈的数据是 %d\n", res);
				} catch (Exception e) {
					// TODO: handle exception
					System.out.println(e.getMessage());
				}
				break;
			case "exit":
				scanner.close();
				loop = false;
				break;
			default:
				break;
			}
		}
		
		System.out.println("程序退出~~~");
	}

}

//定义一个 ArrayStack 表示栈
class ArrayStack {
	private int maxSize; // 栈的大小
	private int[] stack; // 数组，数组模拟栈，数据就放在该数组
	private int top = -1;// top表示栈顶，初始化为-1
	
	//构造器
	public ArrayStack(int maxSize) {
		this.maxSize = maxSize;
		stack = new int[this.maxSize];
	}
	
	//栈满
	public boolean isFull() {
		return top == maxSize - 1;
	}
	//栈空
	public boolean isEmpty() {
		return top == -1;
	}
	//入栈-push
	public void push(int value) {
		//先判断栈是否满
		if(isFull()) {
			System.out.println("栈满");
			return;
		}
		top++;
		stack[top] = value;
	}
	//出栈-pop, 将栈顶的数据返回
	public int pop() {
		//先判断栈是否空
		if(isEmpty()) {
			//抛出异常
			throw new RuntimeException("栈空，没有数据~");
		}
		int value = stack[top];
		top--;
		return value;
	}
	//显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据
	public void list() {
		if(isEmpty()) {
			System.out.println("栈空，没有数据~~");
			return;
		}
		//需要从栈顶开始显示数据
		for(int i = top; i >= 0 ; i--) {
			System.out.printf("stack[%d]=%d\n", i, stack[i]);
		}
	}
	
}
```

#### 简易版

```java
public class ArrayStack {
    private int[] stack;
    private int top;
 
    public ArrayStack(int capacity) {
        stack = new int[capacity];
        top = -1;
    }
 
    public void push(int item) {
        if (top == stack.length - 1) {
            throw new IllegalStateException("Stack is full");
        }
        stack[++top] = item;
    }
 
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return stack[top--];
    }
 
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return stack[top];
    }
 
    public boolean isEmpty() {
        return top == -1;
    }
}
```


### 3.2 基于动态数组的实现方式

使用 **动态数组**（如ArrayList）作为底层数据结构来实现 **栈**，通过在 **动态数组的尾部进行插入和删除操作**来实现栈的功能。**当栈容量不足时，动态数组可以自动进行扩容，当栈元素减少时，动态数组可以自动进行缩容。这种实现方式提供了动态调整容量的特性。**

```java
import java.util.ArrayList;
 
public class DynamicArrayStack {
    private ArrayList<Integer> stack;
 
    public DynamicArrayStack() {
        stack = new ArrayList<>();
    }
 
    public void push(int item) {
        stack.add(item);
    }
 
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return stack.remove(stack.size() - 1);
    }
 
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return stack.get(stack.size() - 1);
    }
 
    public boolean isEmpty() {
        return stack.isEmpty();
    }
}
```

### 3.3 基于链表的实现方式

使用 **链表** 作为底层数据结构来实现 **栈**，链表的头部或尾部作为栈顶，**每次插入和删除操作都在链表的头部进行，通过修改引用来实现栈的操作**。链表实现的栈可以动态增加和缩小容量，不需要提前定义栈的最大容量，但相对于数组实现，需要更多的空间开销。

```java
public class LinkedListStack {
    private Node top;
 
    private class Node {
        int data;
        Node next;
 
        public Node(int data) {
            this.data = data;
            this.next = null;
        }
    }
 
    public LinkedListStack() {
        top = null;
    }
 
    public void push(int item) {
        Node newNode = new Node(item);
        if (isEmpty()) {
            top = newNode;
        } else {
            newNode.next = top;
            top = newNode;
        }
    }
 
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        int item = top.data;
        top = top.next;
        return item;
    }
 
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return top.data;
    }
 
    public boolean isEmpty() {
        return top == null;
    }
}
```

### 3.4  基于数组实现和基于链表实现的比较

- **（1）基于数组实现的栈：**
  - 各个操作都是常数时间开销
  - 每隔一段时间进行的倍增操作的时间开销较大
- **（2）基于链表实现的栈：**
  - 栈规模的增加和减小都很容易
  - 各个操作都是常数时间开销
  - 每个操作都需要使用额外的空间和时间开销来处理指针

### 3.5 基于队列的实现方式

使用 **队列** 作为底层数据结构来实现 **栈**，可以使用两个队列来模拟栈的操作。**当压栈时，将元素添加到非空队列中**；**当弹栈时，将非空队列中的元素依次弹出并放入另一个空队列中，直到剩下最后一个元素**，即栈顶元素，然后弹出。这种实现方式可以保持栈顶元素总是在队列的尾部，模拟了栈的后进先出（LIFO）特性。

```java
import java.util.LinkedList;
import java.util.Queue;
 
public class QueueBasedStack {
    private Queue<Integer> queue1;
    private Queue<Integer> queue2;
    private int top;
 
    public QueueBasedStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
 
    public void push(int item) {
        queue1.add(item);
        top = item;
    }
 
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        while (queue1.size() > 1) {
            top = queue1.remove();
            queue2.add(top);
        }
        int item = queue1.remove();
        Queue<Integer> tempQueue = queue1;
        queue1 = queue2;
        queue2 = tempQueue;
        return item;
    }
 
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return top;
    }
 
    public boolean isEmpty() {
        return queue1.isEmpty();
    }
}
```






